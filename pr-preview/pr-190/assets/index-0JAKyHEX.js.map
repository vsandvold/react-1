{"version":3,"file":"index-0JAKyHEX.js","sources":["../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js","../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js","../../node_modules/.pnpm/@lingui+core@4.7.0/node_modules/@lingui/core/dist/index.mjs"],"sourcesContent":["\"use strict\";\n// NOTE: don't construct errors here or they'll have the wrong stack trace.\n// NOTE: don't make custom error class; the JS engines use `SyntaxError`\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.errorMessages = exports.ErrorType = void 0;\n/**\n * Keys for possible error messages used by `unraw`.\n * Note: These do _not_ map to actual error object types. All errors thrown\n * are `SyntaxError`.\n */\n// Don't use const enum or JS users won't be able to access the enum values\nvar ErrorType;\n(function (ErrorType) {\n    /**\n     * Thrown when a badly formed Unicode escape sequence is found. Possible\n     * reasons include the code being too short (`\"\\u25\"`) or having invalid\n     * characters (`\"\\u2$A5\"`).\n     */\n    ErrorType[\"MalformedUnicode\"] = \"MALFORMED_UNICODE\";\n    /**\n     * Thrown when a badly formed hexadecimal escape sequence is found. Possible\n     * reasons include the code being too short (`\"\\x2\"`) or having invalid\n     * characters (`\"\\x2$\"`).\n     */\n    ErrorType[\"MalformedHexadecimal\"] = \"MALFORMED_HEXADECIMAL\";\n    /**\n     * Thrown when a Unicode code point escape sequence has too high of a code\n     * point. The maximum code point allowed is `\\u{10FFFF}`, so `\\u{110000}` and\n     * higher will throw this error.\n     */\n    ErrorType[\"CodePointLimit\"] = \"CODE_POINT_LIMIT\";\n    /**\n     * Thrown when an octal escape sequences is encountered and `allowOctals` is\n     * `false`. For example, `unraw(\"\\234\", false)`.\n     */\n    ErrorType[\"OctalDeprecation\"] = \"OCTAL_DEPRECATION\";\n    /**\n     * Thrown only when a single backslash is found at the end of a string. For\n     * example, `\"\\\\\"` or `\"test\\\\x24\\\\\"`.\n     */\n    ErrorType[\"EndOfString\"] = \"END_OF_STRING\";\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\n/** Map of error message names to the full text of the message. */\nexports.errorMessages = new Map([\n    [ErrorType.MalformedUnicode, \"malformed Unicode character escape sequence\"],\n    [\n        ErrorType.MalformedHexadecimal,\n        \"malformed hexadecimal character escape sequence\"\n    ],\n    [\n        ErrorType.CodePointLimit,\n        \"Unicode codepoint must not be greater than 0x10FFFF in escape sequence\"\n    ],\n    [\n        ErrorType.OctalDeprecation,\n        '\"0\"-prefixed octal literals and octal escape sequences are deprecated; ' +\n            'for octal literals use the \"0o\" prefix instead'\n    ],\n    [ErrorType.EndOfString, \"malformed escape sequence at end of string\"]\n]);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unraw = exports.errorMessages = exports.ErrorType = void 0;\nconst errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"ErrorType\", { enumerable: true, get: function () { return errors_1.ErrorType; } });\nObject.defineProperty(exports, \"errorMessages\", { enumerable: true, get: function () { return errors_1.errorMessages; } });\n/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex) {\n    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n    return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\n    const parsedHex = parseHexToInt(hex);\n    if (Number.isNaN(parsedHex) ||\n        (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errorName));\n    }\n    return parsedHex;\n}\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code, surrogateCode) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\n    if (surrogateCode !== undefined) {\n        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\n        return String.fromCharCode(parsedCode, parsedSurrogateCode);\n    }\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text) {\n    return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint) {\n    if (!isCurlyBraced(codePoint)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\n    }\n    const withoutBraces = codePoint.slice(1, -1);\n    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\n    try {\n        return String.fromCodePoint(parsedCode);\n    }\n    catch (err) {\n        throw err instanceof RangeError\n            ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit))\n            : err;\n    }\n}\n// Have to give overload that takes boolean for when compiler doesn't know if\n// true or false\nfunction parseOctalCode(code, error = false) {\n    if (error) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\n    }\n    // The original regex only allows digits so we don't need to have a strict\n    // octal parser like hexToInt. Length is not enforced for octals.\n    const parsedCode = parseInt(code, 8);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map([\n    [\"b\", \"\\b\"],\n    [\"f\", \"\\f\"],\n    [\"n\", \"\\n\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"],\n    [\"v\", \"\\v\"],\n    [\"0\", \"\\0\"]\n]);\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code) {\n    return singleCharacterEscapes.get(code) || code;\n}\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nfunction unraw(raw, allowOctals = false) {\n    return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\n        // Compare groups to undefined because empty strings mean different errors\n        // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n        if (backslash !== undefined) {\n            return \"\\\\\";\n        }\n        if (hex !== undefined) {\n            return parseHexadecimalCode(hex);\n        }\n        if (codePoint !== undefined) {\n            return parseUnicodeCodePointCode(codePoint);\n        }\n        if (unicodeWithSurrogate !== undefined) {\n            return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n        }\n        if (unicode !== undefined) {\n            return parseUnicodeCode(unicode);\n        }\n        if (octal === \"0\") {\n            return \"\\0\";\n        }\n        if (octal !== undefined) {\n            return parseOctalCode(octal, !allowOctals);\n        }\n        if (singleCharacter !== undefined) {\n            return parseSingleCharacterCode(singleCharacter);\n        }\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\n    });\n}\nexports.unraw = unraw;\nexports.default = unraw;\n","import unraw from 'unraw';\nimport { compileMessage } from '@lingui/message-utils/compileMessage';\n\nconst isString = (s) => typeof s === \"string\";\nconst isFunction = (f) => typeof f === \"function\";\n\nconst cache = /* @__PURE__ */ new Map();\nconst defaultLocale = \"en\";\nfunction normalizeLocales(locales) {\n  const out = Array.isArray(locales) ? locales : [locales];\n  return [...out, defaultLocale];\n}\nfunction date(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"date\", _locales, format),\n    () => new Intl.DateTimeFormat(_locales, format)\n  );\n  return formatter.format(isString(value) ? new Date(value) : value);\n}\nfunction number(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"number\", _locales, format),\n    () => new Intl.NumberFormat(_locales, format)\n  );\n  return formatter.format(value);\n}\nfunction plural(locales, ordinal, value, { offset = 0, ...rules }) {\n  const _locales = normalizeLocales(locales);\n  const plurals = ordinal ? getMemoized(\n    () => cacheKey(\"plural-ordinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"ordinal\" })\n  ) : getMemoized(\n    () => cacheKey(\"plural-cardinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"cardinal\" })\n  );\n  return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;\n}\nfunction getMemoized(getKey, construct) {\n  const key = getKey();\n  let formatter = cache.get(key);\n  if (!formatter) {\n    formatter = construct();\n    cache.set(key, formatter);\n  }\n  return formatter;\n}\nfunction cacheKey(type, locales, options) {\n  const localeKey = locales.join(\"-\");\n  return `${type}-${localeKey}-${JSON.stringify(options)}`;\n}\n\nconst formats = {\n  __proto__: null,\n  date: date,\n  defaultLocale: defaultLocale,\n  number: number,\n  plural: plural\n};\n\nconst UNICODE_REGEX = /\\\\u[a-fA-F0-9]{4}|\\\\x[a-fA-F0-9]{2}/g;\nconst getDefaultFormats = (locale, passedLocales, formats = {}) => {\n  const locales = passedLocales || locale;\n  const style = (format) => {\n    return typeof format === \"object\" ? format : formats[format] || { style: format };\n  };\n  const replaceOctothorpe = (value, message) => {\n    const numberFormat = Object.keys(formats).length ? style(\"number\") : void 0;\n    const valueStr = number(locales, value, numberFormat);\n    return message.replace(\"#\", valueStr);\n  };\n  return {\n    plural: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, false, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    selectordinal: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, true, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    select: selectFormatter,\n    number: (value, format) => number(locales, value, style(format)),\n    date: (value, format) => date(locales, value, style(format)),\n    undefined: undefinedFormatter\n  };\n};\nconst selectFormatter = (value, rules) => rules[value] ?? rules.other;\nconst undefinedFormatter = (value) => value;\nfunction interpolate(translation, locale, locales) {\n  return (values = {}, formats) => {\n    const formatters = getDefaultFormats(locale, locales, formats);\n    const formatMessage = (message) => {\n      if (!Array.isArray(message))\n        return message;\n      return message.reduce((message2, token) => {\n        if (isString(token))\n          return message2 + token;\n        const [name, type, format] = token;\n        let interpolatedFormat = {};\n        if (format != null && typeof format === \"object\") {\n          Object.entries(format).forEach(([key, value2]) => {\n            interpolatedFormat[key] = formatMessage(value2);\n          });\n        } else {\n          interpolatedFormat = format;\n        }\n        const formatter = formatters[type];\n        const value = formatter(values[name], interpolatedFormat);\n        if (value == null)\n          return message2;\n        return message2 + value;\n      }, \"\");\n    };\n    const result = formatMessage(translation);\n    if (isString(result) && UNICODE_REGEX.test(result)) {\n      return unraw(result.trim());\n    }\n    if (isString(result))\n      return result.trim();\n    return result ? String(result) : \"\";\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventEmitter {\n  constructor() {\n    __publicField$1(this, \"_events\", {});\n  }\n  on(event, listener) {\n    var _a;\n    (_a = this._events)[event] ?? (_a[event] = []);\n    this._events[event].push(listener);\n    return () => this.removeListener(event, listener);\n  }\n  removeListener(event, listener) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    const index = maybeListeners.indexOf(listener);\n    if (~index)\n      maybeListeners.splice(index, 1);\n  }\n  emit(event, ...args) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    maybeListeners.map((listener) => listener.apply(this, args));\n  }\n  _getListeners(event) {\n    const maybeListeners = this._events[event];\n    return Array.isArray(maybeListeners) ? maybeListeners : false;\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass I18n extends EventEmitter {\n  constructor(params) {\n    super();\n    __publicField(this, \"_locale\", \"\");\n    __publicField(this, \"_locales\");\n    __publicField(this, \"_localeData\", {});\n    __publicField(this, \"_messages\", {});\n    __publicField(this, \"_missing\");\n    /**\n     * Alias for {@see I18n._}\n     */\n    __publicField(this, \"t\", this._.bind(this));\n    if (params.missing != null)\n      this._missing = params.missing;\n    if (params.messages != null)\n      this.load(params.messages);\n    if (params.localeData != null)\n      this.loadLocaleData(params.localeData);\n    if (typeof params.locale === \"string\" || params.locales) {\n      this.activate(params.locale ?? defaultLocale, params.locales);\n    }\n  }\n  get locale() {\n    return this._locale;\n  }\n  get locales() {\n    return this._locales;\n  }\n  get messages() {\n    return this._messages[this._locale] ?? {};\n  }\n  /**\n   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4\n   */\n  get localeData() {\n    return this._localeData[this._locale] ?? {};\n  }\n  _loadLocaleData(locale, localeData) {\n    const maybeLocaleData = this._localeData[locale];\n    if (!maybeLocaleData) {\n      this._localeData[locale] = localeData;\n    } else {\n      Object.assign(maybeLocaleData, localeData);\n    }\n  }\n  /**\n   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4\n   */\n  // @ts-ignore deprecated, so ignore the reported error\n  loadLocaleData(localeOrAllData, localeData) {\n    if (localeData != null) {\n      this._loadLocaleData(localeOrAllData, localeData);\n    } else {\n      Object.keys(localeOrAllData).forEach(\n        (locale) => this._loadLocaleData(locale, localeOrAllData[locale])\n      );\n    }\n    this.emit(\"change\");\n  }\n  _load(locale, messages) {\n    const maybeMessages = this._messages[locale];\n    if (!maybeMessages) {\n      this._messages[locale] = messages;\n    } else {\n      Object.assign(maybeMessages, messages);\n    }\n  }\n  load(localeOrMessages, messages) {\n    if (typeof localeOrMessages == \"string\" && typeof messages === \"object\") {\n      this._load(localeOrMessages, messages);\n    } else {\n      Object.entries(localeOrMessages).forEach(\n        ([locale, messages2]) => this._load(locale, messages2)\n      );\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * @param options {@link LoadAndActivateOptions}\n   */\n  loadAndActivate({ locale, locales, messages }) {\n    this._locale = locale;\n    this._locales = locales || void 0;\n    this._messages[this._locale] = messages;\n    this.emit(\"change\");\n  }\n  activate(locale, locales) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!this._messages[locale]) {\n        console.warn(`Messages for locale \"${locale}\" not loaded.`);\n      }\n    }\n    this._locale = locale;\n    this._locales = locales;\n    this.emit(\"change\");\n  }\n  _(id, values, options) {\n    let message = options?.message;\n    if (!isString(id)) {\n      values = id.values || values;\n      message = id.message;\n      id = id.id;\n    }\n    const messageForId = this.messages[id];\n    const messageMissing = messageForId === void 0;\n    const missing = this._missing;\n    if (missing && messageMissing) {\n      return isFunction(missing) ? missing(this._locale, id) : missing;\n    }\n    if (messageMissing) {\n      this.emit(\"missing\", { id, locale: this._locale });\n    }\n    let translation = messageForId || message || id;\n    if (process.env.NODE_ENV !== \"production\") {\n      translation = isString(translation) ? compileMessage(translation) : translation;\n    }\n    if (isString(translation) && UNICODE_REGEX.test(translation))\n      return JSON.parse(`\"${translation}\"`);\n    if (isString(translation))\n      return translation;\n    return interpolate(\n      translation,\n      this._locale,\n      this._locales\n    )(values, options?.formats);\n  }\n  date(value, format) {\n    return date(this._locales || this._locale, value, format);\n  }\n  number(value, format) {\n    return number(this._locales || this._locale, value, format);\n  }\n}\nfunction setupI18n(params = {}) {\n  return new I18n(params);\n}\n\nconst i18n = setupI18n();\n\nexport { I18n, formats, i18n, setupI18n };\n"],"names":["exports","ErrorType","errors_1","require$$0","parseHexToInt","hex","validateAndParseHex","errorName","enforcedLength","parsedHex","parseHexadecimalCode","code","parsedCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","parseUnicodeCodePointCode","codePoint","withoutBraces","err","parseOctalCode","error","singleCharacterEscapes","parseSingleCharacterCode","escapeMatch","unraw","raw","allowOctals","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","isString","s","isFunction","f","cache","defaultLocale","normalizeLocales","locales","date","value","format","_locales","getMemoized","cacheKey","number","plural","ordinal","offset","rules","plurals","getKey","construct","key","formatter","type","options","localeKey","UNICODE_REGEX","getDefaultFormats","locale","passedLocales","formats","style","replaceOctothorpe","message","numberFormat","valueStr","cases","selectFormatter","undefinedFormatter","interpolate","translation","values","formatters","formatMessage","message2","token","name","interpolatedFormat","value2","result","__defProp$1","__defNormalProp$1","obj","__publicField$1","EventEmitter","event","listener","_a","maybeListeners","index","args","__defProp","__defNormalProp","__publicField","I18n","params","localeData","maybeLocaleData","localeOrAllData","messages","maybeMessages","localeOrMessages","messages2","id","messageForId","messageMissing","missing","setupI18n","i18n"],"mappings":"mEAGA,OAAO,eAAcA,EAAU,aAAc,CAAE,MAAO,EAAI,CAAE,EAC5DA,EAAwB,cAAAA,EAAA,UAAoB,OAO5C,IAAIC,GACH,SAAUA,EAAW,CAMlBA,EAAU,iBAAsB,oBAMhCA,EAAU,qBAA0B,wBAMpCA,EAAU,eAAoB,mBAK9BA,EAAU,iBAAsB,oBAKhCA,EAAU,YAAiB,kBAC5BA,EAAYD,EAAQ,YAAcA,EAAoB,UAAA,CAAE,EAAC,EAE5DA,EAAwB,cAAA,IAAI,IAAI,CAC5B,CAACC,EAAU,iBAAkB,6CAA6C,EAC1E,CACIA,EAAU,qBACV,iDACH,EACD,CACIA,EAAU,eACV,wEACH,EACD,CACIA,EAAU,iBACV,uHAEH,EACD,CAACA,EAAU,YAAa,4CAA4C,CACxE,CAAC,oBC1DD,OAAO,eAAcD,EAAU,aAAc,CAAE,MAAO,EAAI,CAAE,EAC5DA,EAAA,MAAgBA,EAAwB,cAAAA,EAAA,UAAoB,OAC5D,MAAME,EAAWC,EACjB,OAAO,eAAeH,EAAS,YAAa,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOE,EAAS,SAAU,CAAI,CAAA,EACjH,OAAO,eAAeF,EAAS,gBAAiB,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOE,EAAS,aAAc,CAAI,CAAA,EASzH,SAASE,EAAcC,EAAK,CAExB,MADuB,CAACA,EAAI,MAAM,YAAY,EACtB,SAASA,EAAK,EAAE,EAAI,GAC/C,CAYD,SAASC,EAAoBD,EAAKE,EAAWC,EAAgB,CACzD,MAAMC,EAAYL,EAAcC,CAAG,EACnC,GAAI,OAAO,MAAMI,CAAS,GACrBD,IAAmB,QAAaA,IAAmBH,EAAI,OACxD,MAAM,IAAI,YAAYH,EAAS,cAAc,IAAIK,CAAS,CAAC,EAE/D,OAAOE,CACV,CASD,SAASC,EAAqBC,EAAM,CAChC,MAAMC,EAAaN,EAAoBK,EAAMT,EAAS,UAAU,qBAAsB,CAAC,EACvF,OAAO,OAAO,aAAaU,CAAU,CACxC,CAWD,SAASC,EAAiBF,EAAMG,EAAe,CAC3C,MAAMF,EAAaN,EAAoBK,EAAMT,EAAS,UAAU,iBAAkB,CAAC,EACnF,GAAIY,IAAkB,OAAW,CAC7B,MAAMC,EAAsBT,EAAoBQ,EAAeZ,EAAS,UAAU,iBAAkB,CAAC,EACrG,OAAO,OAAO,aAAaU,EAAYG,CAAmB,CAC7D,CACD,OAAO,OAAO,aAAaH,CAAU,CACxC,CAMD,SAASI,EAAcC,EAAM,CACzB,OAAOA,EAAK,OAAO,CAAC,IAAM,KAAOA,EAAK,OAAOA,EAAK,OAAS,CAAC,IAAM,GACrE,CASD,SAASC,EAA0BC,EAAW,CAC1C,GAAI,CAACH,EAAcG,CAAS,EACxB,MAAM,IAAI,YAAYjB,EAAS,cAAc,IAAIA,EAAS,UAAU,gBAAgB,CAAC,EAEzF,MAAMkB,EAAgBD,EAAU,MAAM,EAAG,EAAE,EACrCP,EAAaN,EAAoBc,EAAelB,EAAS,UAAU,gBAAgB,EACzF,GAAI,CACA,OAAO,OAAO,cAAcU,CAAU,CACzC,OACMS,EAAK,CACR,MAAMA,aAAe,WACf,IAAI,YAAYnB,EAAS,cAAc,IAAIA,EAAS,UAAU,cAAc,CAAC,EAC7EmB,CACT,CACJ,CAGD,SAASC,EAAeX,EAAMY,EAAQ,GAAO,CACzC,GAAIA,EACA,MAAM,IAAI,YAAYrB,EAAS,cAAc,IAAIA,EAAS,UAAU,gBAAgB,CAAC,EAIzF,MAAMU,EAAa,SAASD,EAAM,CAAC,EACnC,OAAO,OAAO,aAAaC,CAAU,CACxC,CAKD,MAAMY,EAAyB,IAAI,IAAI,CACnC,CAAC,IAAK,IAAI,EACV,CAAC,IAAK,IAAI,EACV,CAAC,IAAK;AAAA,CAAI,EACV,CAAC,IAAK,IAAI,EACV,CAAC,IAAK,GAAI,EACV,CAAC,IAAK,IAAI,EACV,CAAC,IAAK,IAAI,CACd,CAAC,EAMD,SAASC,EAAyBd,EAAM,CACpC,OAAOa,EAAuB,IAAIb,CAAI,GAAKA,CAC9C,CAiBD,MAAMe,EAAc,yHAUpB,SAASC,EAAMC,EAAKC,EAAc,GAAO,CACrC,OAAOD,EAAI,QAAQF,EAAa,SAAUI,EAAGC,EAAW1B,EAAKc,EAAWa,EAAsBC,EAAWC,EAASC,EAAOC,EAAiB,CAGtI,GAAIL,IAAc,OACd,MAAO,KAEX,GAAI1B,IAAQ,OACR,OAAOK,EAAqBL,CAAG,EAEnC,GAAIc,IAAc,OACd,OAAOD,EAA0BC,CAAS,EAE9C,GAAIa,IAAyB,OACzB,OAAOnB,EAAiBmB,EAAsBC,CAAS,EAE3D,GAAIC,IAAY,OACZ,OAAOrB,EAAiBqB,CAAO,EAEnC,GAAIC,IAAU,IACV,MAAO,KAEX,GAAIA,IAAU,OACV,OAAOb,EAAea,EAAO,CAACN,CAAW,EAE7C,GAAIO,IAAoB,OACpB,OAAOX,EAAyBW,CAAe,EAEnD,MAAM,IAAI,YAAYlC,EAAS,cAAc,IAAIA,EAAS,UAAU,WAAW,CAAC,CACxF,CAAK,CACJ,CACDF,EAAA,MAAgB2B,EAChB3B,EAAA,QAAkB2B,oBCzLZU,EAAYC,GAAM,OAAOA,GAAM,SAC/BC,EAAcC,GAAM,OAAOA,GAAM,WAEjCC,MAA4B,IAC5BC,EAAgB,KACtB,SAASC,EAAiBC,EAAS,CAE1B,MAAA,CAAC,GADI,MAAM,QAAQA,CAAO,EAAIA,EAAU,CAACA,CAAO,EACvCF,CAAa,CAC/B,CACA,SAASG,EAAKD,EAASE,EAAOC,EAAQ,CAC9B,MAAAC,EAAWL,EAAiBC,CAAO,EAKlC,OAJWK,EAChB,IAAMC,EAAS,OAAQF,EAAUD,CAAM,EACvC,IAAM,IAAI,KAAK,eAAeC,EAAUD,CAAM,CAAA,EAE/B,OAAOV,EAASS,CAAK,EAAI,IAAI,KAAKA,CAAK,EAAIA,CAAK,CACnE,CACA,SAASK,EAAOP,EAASE,EAAOC,EAAQ,CAChC,MAAAC,EAAWL,EAAiBC,CAAO,EAKlC,OAJWK,EAChB,IAAMC,EAAS,SAAUF,EAAUD,CAAM,EACzC,IAAM,IAAI,KAAK,aAAaC,EAAUD,CAAM,CAAA,EAE7B,OAAOD,CAAK,CAC/B,CACA,SAASM,EAAOR,EAASS,EAASP,EAAO,CAAE,OAAAQ,EAAS,EAAG,GAAGC,GAAS,CAC3D,MAAAP,EAAWL,EAAiBC,CAAO,EACnCY,EAAUH,EAAUJ,EACxB,IAAMC,EAAS,iBAAkBF,CAAQ,EACzC,IAAM,IAAI,KAAK,YAAYA,EAAU,CAAE,KAAM,UAAW,CAAA,EACtDC,EACF,IAAMC,EAAS,kBAAmBF,CAAQ,EAC1C,IAAM,IAAI,KAAK,YAAYA,EAAU,CAAE,KAAM,WAAY,CAAA,EAEpD,OAAAO,EAAMT,CAAK,GAAKS,EAAMC,EAAQ,OAAOV,EAAQQ,CAAM,CAAC,GAAKC,EAAM,KACxE,CACA,SAASN,EAAYQ,EAAQC,EAAW,CACtC,MAAMC,EAAMF,IACR,IAAAG,EAAYnB,EAAM,IAAIkB,CAAG,EAC7B,OAAKC,IACHA,EAAYF,EAAU,EAChBjB,EAAA,IAAIkB,EAAKC,CAAS,GAEnBA,CACT,CACA,SAASV,EAASW,EAAMjB,EAASkB,EAAS,CAClC,MAAAC,EAAYnB,EAAQ,KAAK,GAAG,EAC3B,MAAA,GAAGiB,CAAI,IAAIE,CAAS,IAAI,KAAK,UAAUD,CAAO,CAAC,EACxD,CAUA,MAAME,EAAgB,uCAChBC,EAAoB,CAACC,EAAQC,EAAeC,EAAU,CAAA,IAAO,CACjE,MAAMxB,EAAUuB,GAAiBD,EAC3BG,EAAStB,GACN,OAAOA,GAAW,SAAWA,EAASqB,EAAQrB,CAAM,GAAK,CAAE,MAAOA,GAErEuB,EAAoB,CAACxB,EAAOyB,IAAY,CACtC,MAAAC,EAAe,OAAO,KAAKJ,CAAO,EAAE,OAASC,EAAM,QAAQ,EAAI,OAC/DI,EAAWtB,EAAOP,EAASE,EAAO0B,CAAY,EAC7C,OAAAD,EAAQ,QAAQ,IAAKE,CAAQ,CAAA,EAE/B,MAAA,CACL,OAAQ,CAAC3B,EAAO4B,IAAU,CAClB,KAAA,CAAE,OAAApB,EAAS,CAAM,EAAAoB,EACjBH,EAAUnB,EAAOR,EAAS,GAAOE,EAAO4B,CAAK,EAC5C,OAAAJ,EAAkBxB,EAAQQ,EAAQiB,CAAO,CAClD,EACA,cAAe,CAACzB,EAAO4B,IAAU,CACzB,KAAA,CAAE,OAAApB,EAAS,CAAM,EAAAoB,EACjBH,EAAUnB,EAAOR,EAAS,GAAME,EAAO4B,CAAK,EAC3C,OAAAJ,EAAkBxB,EAAQQ,EAAQiB,CAAO,CAClD,EACA,OAAQI,EACR,OAAQ,CAAC7B,EAAOC,IAAWI,EAAOP,EAASE,EAAOuB,EAAMtB,CAAM,CAAC,EAC/D,KAAM,CAACD,EAAOC,IAAWF,EAAKD,EAASE,EAAOuB,EAAMtB,CAAM,CAAC,EAC3D,UAAW6B,CAAA,CAEf,EACMD,EAAkB,CAAC7B,EAAOS,IAAUA,EAAMT,CAAK,GAAKS,EAAM,MAC1DqB,EAAsB9B,GAAUA,EACtC,SAAS+B,EAAYC,EAAaZ,EAAQtB,EAAS,CACjD,MAAO,CAACmC,EAAS,CAAC,EAAGX,IAAY,CAC/B,MAAMY,EAAaf,EAAkBC,EAAQtB,EAASwB,CAAO,EACvDa,EAAiBV,GAChB,MAAM,QAAQA,CAAO,EAEnBA,EAAQ,OAAO,CAACW,EAAUC,IAAU,CACzC,GAAI9C,EAAS8C,CAAK,EAChB,OAAOD,EAAWC,EACpB,KAAM,CAACC,EAAMvB,EAAMd,CAAM,EAAIoC,EAC7B,IAAIE,EAAqB,CAAA,EACrBtC,GAAU,MAAQ,OAAOA,GAAW,SAC/B,OAAA,QAAQA,CAAM,EAAE,QAAQ,CAAC,CAACY,EAAK2B,CAAM,IAAM,CAC7BD,EAAA1B,CAAG,EAAIsB,EAAcK,CAAM,CAAA,CAC/C,EAEoBD,EAAAtC,EAEjB,MAAAa,EAAYoB,EAAWnB,CAAI,EAC3Bf,EAAQc,EAAUmB,EAAOK,CAAI,EAAGC,CAAkB,EACxD,OAAIvC,GAAS,KACJoC,EACFA,EAAWpC,GACjB,EAAE,EAlBIyB,EAoBLgB,EAASN,EAAcH,CAAW,EACxC,OAAIzC,EAASkD,CAAM,GAAKvB,EAAc,KAAKuB,CAAM,EACxC5D,EAAM4D,EAAO,KAAA,CAAM,EAExBlD,EAASkD,CAAM,EACVA,EAAO,OACTA,EAAS,OAAOA,CAAM,EAAI,EAAA,CAErC,CAEA,IAAIC,EAAc,OAAO,eACrBC,EAAoB,CAACC,EAAK/B,EAAKb,IAAUa,KAAO+B,EAAMF,EAAYE,EAAK/B,EAAK,CAAE,WAAY,GAAM,aAAc,GAAM,SAAU,GAAM,MAAAb,CAAO,CAAA,EAAI4C,EAAI/B,CAAG,EAAIb,EAC1J6C,EAAkB,CAACD,EAAK/B,EAAKb,KAC/B2C,EAAkBC,EAAK,OAAO/B,GAAQ,SAAWA,EAAM,GAAKA,EAAKb,CAAK,EAC/DA,GAET,MAAM8C,CAAa,CACjB,aAAc,CACID,EAAA,KAAM,UAAW,CAAA,CAAE,CACrC,CACA,GAAGE,EAAOC,EAAU,CACd,IAAAC,EACH,OAAAA,EAAK,KAAK,SAASF,CAAK,IAAME,EAAGF,CAAK,EAAI,CAAA,GAC3C,KAAK,QAAQA,CAAK,EAAE,KAAKC,CAAQ,EAC1B,IAAM,KAAK,eAAeD,EAAOC,CAAQ,CAClD,CACA,eAAeD,EAAOC,EAAU,CACxB,MAAAE,EAAiB,KAAK,cAAcH,CAAK,EAC/C,GAAI,CAACG,EACH,OACI,MAAAC,EAAQD,EAAe,QAAQF,CAAQ,EACzC,CAACG,GACYD,EAAA,OAAOC,EAAO,CAAC,CAClC,CACA,KAAKJ,KAAUK,EAAM,CACb,MAAAF,EAAiB,KAAK,cAAcH,CAAK,EAC1CG,GAELA,EAAe,IAAKF,GAAaA,EAAS,MAAM,KAAMI,CAAI,CAAC,CAC7D,CACA,cAAcL,EAAO,CACb,MAAAG,EAAiB,KAAK,QAAQH,CAAK,EACzC,OAAO,MAAM,QAAQG,CAAc,EAAIA,EAAiB,EAC1D,CACF,CAEA,IAAIG,EAAY,OAAO,eACnBC,EAAkB,CAACV,EAAK/B,EAAKb,IAAUa,KAAO+B,EAAMS,EAAUT,EAAK/B,EAAK,CAAE,WAAY,GAAM,aAAc,GAAM,SAAU,GAAM,MAAAb,CAAO,CAAA,EAAI4C,EAAI/B,CAAG,EAAIb,EACtJuD,EAAgB,CAACX,EAAK/B,EAAKb,KAC7BsD,EAAgBV,EAAK,OAAO/B,GAAQ,SAAWA,EAAM,GAAKA,EAAKb,CAAK,EAC7DA,GAET,MAAMwD,UAAaV,CAAa,CAC9B,YAAYW,EAAQ,CACZ,QACQF,EAAA,KAAM,UAAW,EAAE,EACjCA,EAAc,KAAM,UAAU,EAChBA,EAAA,KAAM,cAAe,CAAA,CAAE,EACvBA,EAAA,KAAM,YAAa,CAAA,CAAE,EACnCA,EAAc,KAAM,UAAU,EAI9BA,EAAc,KAAM,IAAK,KAAK,EAAE,KAAK,IAAI,CAAC,EACtCE,EAAO,SAAW,OACpB,KAAK,SAAWA,EAAO,SACrBA,EAAO,UAAY,MAChB,KAAA,KAAKA,EAAO,QAAQ,EACvBA,EAAO,YAAc,MAClB,KAAA,eAAeA,EAAO,UAAU,GACnC,OAAOA,EAAO,QAAW,UAAYA,EAAO,UAC9C,KAAK,SAASA,EAAO,QAAU7D,EAAe6D,EAAO,OAAO,CAEhE,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,SAAU,CACZ,OAAO,KAAK,QACd,CACA,IAAI,UAAW,CACb,OAAO,KAAK,UAAU,KAAK,OAAO,GAAK,CAAA,CACzC,CAIA,IAAI,YAAa,CACf,OAAO,KAAK,YAAY,KAAK,OAAO,GAAK,CAAA,CAC3C,CACA,gBAAgBrC,EAAQsC,EAAY,CAC5B,MAAAC,EAAkB,KAAK,YAAYvC,CAAM,EAC1CuC,EAGI,OAAA,OAAOA,EAAiBD,CAAU,EAFpC,KAAA,YAAYtC,CAAM,EAAIsC,CAI/B,CAKA,eAAeE,EAAiBF,EAAY,CACtCA,GAAc,KACX,KAAA,gBAAgBE,EAAiBF,CAAU,EAEzC,OAAA,KAAKE,CAAe,EAAE,QAC1BxC,GAAW,KAAK,gBAAgBA,EAAQwC,EAAgBxC,CAAM,CAAC,CAAA,EAGpE,KAAK,KAAK,QAAQ,CACpB,CACA,MAAMA,EAAQyC,EAAU,CAChB,MAAAC,EAAgB,KAAK,UAAU1C,CAAM,EACtC0C,EAGI,OAAA,OAAOA,EAAeD,CAAQ,EAFhC,KAAA,UAAUzC,CAAM,EAAIyC,CAI7B,CACA,KAAKE,EAAkBF,EAAU,CAC3B,OAAOE,GAAoB,UAAY,OAAOF,GAAa,SACxD,KAAA,MAAME,EAAkBF,CAAQ,EAE9B,OAAA,QAAQE,CAAgB,EAAE,QAC/B,CAAC,CAAC3C,EAAQ4C,CAAS,IAAM,KAAK,MAAM5C,EAAQ4C,CAAS,CAAA,EAGzD,KAAK,KAAK,QAAQ,CACpB,CAIA,gBAAgB,CAAE,OAAA5C,EAAQ,QAAAtB,EAAS,SAAA+D,GAAY,CAC7C,KAAK,QAAUzC,EACf,KAAK,SAAWtB,GAAW,OACtB,KAAA,UAAU,KAAK,OAAO,EAAI+D,EAC/B,KAAK,KAAK,QAAQ,CACpB,CACA,SAASzC,EAAQtB,EAAS,CAMxB,KAAK,QAAUsB,EACf,KAAK,SAAWtB,EAChB,KAAK,KAAK,QAAQ,CACpB,CACA,EAAEmE,EAAIhC,EAAQjB,EAAS,CACrB,IAAIS,EAAUT,GAAA,YAAAA,EAAS,QAClBzB,EAAS0E,CAAE,IACdhC,EAASgC,EAAG,QAAUhC,EACtBR,EAAUwC,EAAG,QACbA,EAAKA,EAAG,IAEJ,MAAAC,EAAe,KAAK,SAASD,CAAE,EAC/BE,EAAiBD,IAAiB,OAClCE,EAAU,KAAK,SACrB,GAAIA,GAAWD,EACb,OAAO1E,EAAW2E,CAAO,EAAIA,EAAQ,KAAK,QAASH,CAAE,EAAIG,EAEvDD,GACF,KAAK,KAAK,UAAW,CAAE,GAAAF,EAAI,OAAQ,KAAK,QAAS,EAE/C,IAAAjC,EAAckC,GAAgBzC,GAAWwC,EAI7C,OAAI1E,EAASyC,CAAW,GAAKd,EAAc,KAAKc,CAAW,EAClD,KAAK,MAAM,IAAIA,CAAW,GAAG,EAClCzC,EAASyC,CAAW,EACfA,EACFD,EACLC,EACA,KAAK,QACL,KAAK,QAAA,EACLC,EAAQjB,GAAA,YAAAA,EAAS,OAAO,CAC5B,CACA,KAAKhB,EAAOC,EAAQ,CAClB,OAAOF,EAAK,KAAK,UAAY,KAAK,QAASC,EAAOC,CAAM,CAC1D,CACA,OAAOD,EAAOC,EAAQ,CACpB,OAAOI,EAAO,KAAK,UAAY,KAAK,QAASL,EAAOC,CAAM,CAC5D,CACF,CACA,SAASoE,EAAUZ,EAAS,GAAI,CACvB,OAAA,IAAID,EAAKC,CAAM,CACxB,CAEA,MAAMa,EAAOD,EAAU","x_google_ignoreList":[0,1,2]}