{"version":3,"file":"i18n-G6_82uWZ.js","sources":["../../node_modules/.pnpm/unraw@2.0.1/node_modules/unraw/dist/errors.js","../../node_modules/.pnpm/unraw@2.0.1/node_modules/unraw/dist/index.js","../../node_modules/.pnpm/@lingui+core@4.3.0/node_modules/@lingui/core/dist/index.mjs","../../packages/i18n.ts"],"sourcesContent":["\"use strict\";\r\n/**\r\n * @file **unraw - errors.ts** | Error messages used by `unraw`.\r\n * @author Ian Sanders\r\n * @copyright 2019 Ian Sanders\r\n * @license MIT\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// NOTE: don't construct errors here or they'll have the wrong stack trace.\r\n// NOTE: don't make custom error class; the JS engines use `SyntaxError`\r\n/**\r\n * Keys for possible error messages used by `unraw`.\r\n * Note: These do _not_ map to actual error object types. All errors thrown\r\n * are `SyntaxError`.\r\n */\r\n// Don't use const enum or JS users won't be able to access the enum values\r\nvar ErrorType;\r\n(function (ErrorType) {\r\n    /**\r\n     * Thrown when a badly formed Unicode escape sequence is found. Possible\r\n     * reasons include the code being too short (`\"\\u25\"`) or having invalid\r\n     * characters (`\"\\u2$A5\"`).\r\n     */\r\n    ErrorType[\"MalformedUnicode\"] = \"MALFORMED_UNICODE\";\r\n    /**\r\n     * Thrown when a badly formed hexadecimal escape sequence is found. Possible\r\n     * reasons include the code being too short (`\"\\x2\"`) or having invalid\r\n     * characters (`\"\\x2$\"`).\r\n     */\r\n    ErrorType[\"MalformedHexadecimal\"] = \"MALFORMED_HEXADECIMAL\";\r\n    /**\r\n     * Thrown when a Unicode code point escape sequence has too high of a code\r\n     * point. The maximum code point allowed is `\\u{10FFFF}`, so `\\u{110000}` and\r\n     * higher will throw this error.\r\n     */\r\n    ErrorType[\"CodePointLimit\"] = \"CODE_POINT_LIMIT\";\r\n    /**\r\n     * Thrown when an octal escape sequences is encountered and `allowOctals` is\r\n     * `false`. For example, `unraw(\"\\234\", false)`.\r\n     */\r\n    ErrorType[\"OctalDeprecation\"] = \"OCTAL_DEPRECATION\";\r\n    /**\r\n     * Thrown only when a single backslash is found at the end of a string. For\r\n     * example, `\"\\\\\"` or `\"test\\\\x24\\\\\"`.\r\n     */\r\n    ErrorType[\"EndOfString\"] = \"END_OF_STRING\";\r\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\r\n/** Map of error message names to the full text of the message. */\r\nexports.errorMessages = new Map([\r\n    [ErrorType.MalformedUnicode, \"malformed Unicode character escape sequence\"],\r\n    [\r\n        ErrorType.MalformedHexadecimal,\r\n        \"malformed hexadecimal character escape sequence\"\r\n    ],\r\n    [\r\n        ErrorType.CodePointLimit,\r\n        \"Unicode codepoint must not be greater than 0x10FFFF in escape sequence\"\r\n    ],\r\n    [\r\n        ErrorType.OctalDeprecation,\r\n        '\"0\"-prefixed octal literals and octal escape sequences are deprecated; ' +\r\n            'for octal literals use the \"0o\" prefix instead'\r\n    ],\r\n    [ErrorType.EndOfString, \"malformed escape sequence at end of string\"]\r\n]);\r\n//# sourceMappingURL=errors.js.map","\"use strict\";\r\n/**\r\n * @file **unraw** | Convert raw escape sequences to their respective characters\r\n * (undo `String.raw`).\r\n * @author Ian Sanders\r\n * @copyright 2019 Ian Sanders\r\n * @license MIT\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst errors_1 = require(\"./errors\");\r\nexports.ErrorType = errors_1.ErrorType;\r\nexports.errorMessages = errors_1.errorMessages;\r\n/**\r\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\r\n * will not allow any other characters, including (for example) \"+\", \"-\", and\r\n * \".\".\r\n * @param hex A string containing a hexadecimal number.\r\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\r\n * number.\r\n */\r\nfunction parseHexToInt(hex) {\r\n    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\r\n    return isOnlyHexChars ? parseInt(hex, 16) : NaN;\r\n}\r\n/**\r\n * Check the validity and length of a hexadecimal code and optionally enforces\r\n * a specific number of hex digits.\r\n * @param hex The string to validate and parse.\r\n * @param errorName The name of the error message to throw a `SyntaxError` with\r\n * if `hex` is invalid. This is used to index `errorMessages`.\r\n * @param enforcedLength If provided, will throw an error if `hex` is not\r\n * exactly this many characters.\r\n * @returns The parsed hex number as a normal number.\r\n * @throws {SyntaxError} If the code is not valid.\r\n */\r\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\r\n    const parsedHex = parseHexToInt(hex);\r\n    if (Number.isNaN(parsedHex) ||\r\n        (enforcedLength !== undefined && enforcedLength !== hex.length)) {\r\n        throw new SyntaxError(errors_1.errorMessages.get(errorName));\r\n    }\r\n    return parsedHex;\r\n}\r\n/**\r\n * Parse a two-digit hexadecimal character escape code.\r\n * @param code The two-digit hexadecimal number that represents the character to\r\n * output.\r\n * @returns The single character represented by the code.\r\n * @throws {SyntaxError} If the code is not valid hex or is not the right\r\n * length.\r\n */\r\nfunction parseHexadecimalCode(code) {\r\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\r\n    return String.fromCharCode(parsedCode);\r\n}\r\n/**\r\n * Parse a four-digit Unicode character escape code.\r\n * @param code The four-digit unicode number that represents the character to\r\n * output.\r\n * @param surrogateCode Optional four-digit unicode surrogate that represents\r\n * the other half of the character to output.\r\n * @returns The single character represented by the code.\r\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\r\n * length.\r\n */\r\nfunction parseUnicodeCode(code, surrogateCode) {\r\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\r\n    if (surrogateCode !== undefined) {\r\n        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\r\n        return String.fromCharCode(parsedCode, parsedSurrogateCode);\r\n    }\r\n    return String.fromCharCode(parsedCode);\r\n}\r\n/**\r\n * Test if the text is surrounded by curly braces (`{}`).\r\n * @param text Text to check.\r\n * @returns `true` if the text is in the form `{*}`.\r\n */\r\nfunction isCurlyBraced(text) {\r\n    return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\r\n}\r\n/**\r\n * Parse a Unicode code point character escape code.\r\n * @param codePoint A unicode escape code point, including the surrounding curly\r\n * braces.\r\n * @returns The single character represented by the code.\r\n * @throws {SyntaxError} If the code is not valid hex or does not have the\r\n * surrounding curly braces.\r\n */\r\nfunction parseUnicodeCodePointCode(codePoint) {\r\n    if (!isCurlyBraced(codePoint)) {\r\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\r\n    }\r\n    const withoutBraces = codePoint.slice(1, -1);\r\n    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\r\n    try {\r\n        return String.fromCodePoint(parsedCode);\r\n    }\r\n    catch (err) {\r\n        throw err instanceof RangeError\r\n            ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit))\r\n            : err;\r\n    }\r\n}\r\n// Have to give overload that takes boolean for when compiler doesn't know if\r\n// true or false\r\nfunction parseOctalCode(code, error = false) {\r\n    if (error) {\r\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\r\n    }\r\n    // The original regex only allows digits so we don't need to have a strict\r\n    // octal parser like hexToInt. Length is not enforced for octals.\r\n    const parsedCode = parseInt(code, 8);\r\n    return String.fromCharCode(parsedCode);\r\n}\r\n/**\r\n * Map of unescaped letters to their corresponding special JS escape characters.\r\n * Intentionally does not include characters that map to themselves like \"\\'\".\r\n */\r\nconst singleCharacterEscapes = new Map([\r\n    [\"b\", \"\\b\"],\r\n    [\"f\", \"\\f\"],\r\n    [\"n\", \"\\n\"],\r\n    [\"r\", \"\\r\"],\r\n    [\"t\", \"\\t\"],\r\n    [\"v\", \"\\v\"],\r\n    [\"0\", \"\\0\"]\r\n]);\r\n/**\r\n * Parse a single character escape sequence and return the matching character.\r\n * If none is matched, defaults to `code`.\r\n * @param code A single character code.\r\n */\r\nfunction parseSingleCharacterCode(code) {\r\n    return singleCharacterEscapes.get(code) || code;\r\n}\r\n/**\r\n * Matches every escape sequence possible, including invalid ones.\r\n *\r\n * All capture groups (described below) are unique (only one will match), except\r\n * for 4, which can only potentially match if 3 does.\r\n *\r\n * **Capture Groups:**\r\n * 0. A single backslash\r\n * 1. Hexadecimal code\r\n * 2. Unicode code point code with surrounding curly braces\r\n * 3. Unicode escape code with surrogate\r\n * 4. Surrogate code\r\n * 5. Unicode escape code without surrogate\r\n * 6. Octal code _NOTE: includes \"0\"._\r\n * 7. A single character (will never be \\, x, u, or 0-3)\r\n */\r\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\r\n/**\r\n * Replace raw escape character strings with their escape characters.\r\n * @param raw A string where escape characters are represented as raw string\r\n * values like `\\'` rather than `'`.\r\n * @param allowOctals If `true`, will process the now-deprecated octal escape\r\n * sequences (ie, `\\111`).\r\n * @returns The processed string, with escape characters replaced by their\r\n * respective actual Unicode characters.\r\n */\r\nfunction unraw(raw, allowOctals = false) {\r\n    return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\r\n        // Compare groups to undefined because empty strings mean different errors\r\n        // Otherwise, `\\u` would fail the same as `\\` which is wrong.\r\n        if (backslash !== undefined) {\r\n            return \"\\\\\";\r\n        }\r\n        if (hex !== undefined) {\r\n            return parseHexadecimalCode(hex);\r\n        }\r\n        if (codePoint !== undefined) {\r\n            return parseUnicodeCodePointCode(codePoint);\r\n        }\r\n        if (unicodeWithSurrogate !== undefined) {\r\n            return parseUnicodeCode(unicodeWithSurrogate, surrogate);\r\n        }\r\n        if (unicode !== undefined) {\r\n            return parseUnicodeCode(unicode);\r\n        }\r\n        if (octal === \"0\") {\r\n            return \"\\0\";\r\n        }\r\n        if (octal !== undefined) {\r\n            return parseOctalCode(octal, !allowOctals);\r\n        }\r\n        if (singleCharacter !== undefined) {\r\n            return parseSingleCharacterCode(singleCharacter);\r\n        }\r\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\r\n    });\r\n}\r\nexports.unraw = unraw;\r\nexports.default = unraw;\r\n//# sourceMappingURL=index.js.map","import unraw from 'unraw';\nimport { compileMessage } from '@lingui/message-utils/compileMessage';\n\nconst isString = (s) => typeof s === \"string\";\nconst isFunction = (f) => typeof f === \"function\";\n\nconst cache = /* @__PURE__ */ new Map();\nfunction normalizeLocales(locales) {\n  const out = Array.isArray(locales) ? locales : [locales];\n  return [...out, \"en\"];\n}\nfunction date(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"date\", _locales, format),\n    () => new Intl.DateTimeFormat(_locales, format)\n  );\n  return formatter.format(isString(value) ? new Date(value) : value);\n}\nfunction number(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"number\", _locales, format),\n    () => new Intl.NumberFormat(_locales, format)\n  );\n  return formatter.format(value);\n}\nfunction plural(locales, ordinal, value, { offset = 0, ...rules }) {\n  const _locales = normalizeLocales(locales);\n  const plurals = ordinal ? getMemoized(\n    () => cacheKey(\"plural-ordinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"ordinal\" })\n  ) : getMemoized(\n    () => cacheKey(\"plural-cardinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"cardinal\" })\n  );\n  return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;\n}\nfunction getMemoized(getKey, construct) {\n  const key = getKey();\n  let formatter = cache.get(key);\n  if (!formatter) {\n    formatter = construct();\n    cache.set(key, formatter);\n  }\n  return formatter;\n}\nfunction cacheKey(type, locales, options) {\n  const localeKey = locales.join(\"-\");\n  return `${type}-${localeKey}-${JSON.stringify(options)}`;\n}\n\nconst formats = {\n  __proto__: null,\n  date: date,\n  number: number,\n  plural: plural\n};\n\nconst UNICODE_REGEX = /\\\\u[a-fA-F0-9]{4}|\\\\x[a-fA-F0-9]{2}/g;\nconst getDefaultFormats = (locale, locales, formats = {}) => {\n  locales = locales || locale;\n  const style = (format) => isString(format) ? formats[format] || { style: format } : format;\n  const replaceOctothorpe = (value, message) => {\n    const numberFormat = Object.keys(formats).length ? style(\"number\") : {};\n    const valueStr = number(locales, value, numberFormat);\n    return message.replace(\"#\", valueStr);\n  };\n  return {\n    plural: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, false, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    selectordinal: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, true, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    select: (value, rules) => rules[value] ?? rules.other,\n    number: (value, format) => number(locales, value, style(format)),\n    date: (value, format) => date(locales, value, style(format)),\n    undefined: (value) => value\n  };\n};\nfunction interpolate(translation, locale, locales) {\n  return (values, formats = {}) => {\n    const formatters = getDefaultFormats(locale, locales, formats);\n    const formatMessage = (message) => {\n      if (!Array.isArray(message))\n        return message;\n      return message.reduce((message2, token) => {\n        if (isString(token))\n          return message2 + token;\n        const [name, type, format] = token;\n        let interpolatedFormat = {};\n        if (format != null && !isString(format)) {\n          Object.keys(format).forEach((key) => {\n            interpolatedFormat[key] = formatMessage(format[key]);\n          });\n        } else {\n          interpolatedFormat = format;\n        }\n        const value = formatters[type](values[name], interpolatedFormat);\n        if (value == null)\n          return message2;\n        return message2 + value;\n      }, \"\");\n    };\n    const result = formatMessage(translation);\n    if (isString(result) && UNICODE_REGEX.test(result)) {\n      return unraw(result.trim());\n    }\n    if (isString(result))\n      return result.trim();\n    return result;\n  };\n}\n\nclass EventEmitter {\n  constructor() {\n    this._events = {};\n  }\n  on(event, listener) {\n    if (!this._hasEvent(event))\n      this._events[event] = [];\n    this._events[event].push(listener);\n    return () => this.removeListener(event, listener);\n  }\n  removeListener(event, listener) {\n    if (!this._hasEvent(event))\n      return;\n    const index = this._events[event].indexOf(listener);\n    if (~index)\n      this._events[event].splice(index, 1);\n  }\n  emit(event, ...args) {\n    if (!this._hasEvent(event))\n      return;\n    this._events[event].map((listener) => listener.apply(this, args));\n  }\n  _hasEvent(event) {\n    return Array.isArray(this._events[event]);\n  }\n}\n\nclass I18n extends EventEmitter {\n  constructor(params) {\n    super();\n    /**\n     * Alias for {@see I18n._}\n     */\n    this.t = this._.bind(this);\n    this._messages = {};\n    this._localeData = {};\n    if (params.missing != null)\n      this._missing = params.missing;\n    if (params.messages != null)\n      this.load(params.messages);\n    if (params.localeData != null)\n      this.loadLocaleData(params.localeData);\n    if (params.locale != null || params.locales != null) {\n      this.activate(params.locale, params.locales);\n    }\n  }\n  get locale() {\n    return this._locale;\n  }\n  get locales() {\n    return this._locales;\n  }\n  get messages() {\n    return this._messages[this._locale] ?? {};\n  }\n  /**\n   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4\n   */\n  get localeData() {\n    return this._localeData[this._locale] ?? {};\n  }\n  _loadLocaleData(locale, localeData) {\n    if (this._localeData[locale] == null) {\n      this._localeData[locale] = localeData;\n    } else {\n      Object.assign(this._localeData[locale], localeData);\n    }\n  }\n  /**\n   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4\n   */\n  loadLocaleData(localeOrAllData, localeData) {\n    if (localeData != null) {\n      this._loadLocaleData(localeOrAllData, localeData);\n    } else {\n      Object.keys(localeOrAllData).forEach(\n        (locale) => this._loadLocaleData(locale, localeOrAllData[locale])\n      );\n    }\n    this.emit(\"change\");\n  }\n  _load(locale, messages) {\n    if (this._messages[locale] == null) {\n      this._messages[locale] = messages;\n    } else {\n      Object.assign(this._messages[locale], messages);\n    }\n  }\n  load(localeOrMessages, messages) {\n    if (messages != null) {\n      this._load(localeOrMessages, messages);\n    } else {\n      Object.keys(localeOrMessages).forEach(\n        (locale) => this._load(locale, localeOrMessages[locale])\n      );\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * @param options {@link LoadAndActivateOptions}\n   */\n  loadAndActivate({ locale, locales, messages }) {\n    this._locale = locale;\n    this._locales = locales || void 0;\n    this._messages[this._locale] = messages;\n    this.emit(\"change\");\n  }\n  activate(locale, locales) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!this._messages[locale]) {\n        console.warn(`Messages for locale \"${locale}\" not loaded.`);\n      }\n    }\n    this._locale = locale;\n    this._locales = locales;\n    this.emit(\"change\");\n  }\n  _(id, values = {}, { message, formats } = {}) {\n    if (!isString(id)) {\n      values = id.values || values;\n      message = id.message;\n      id = id.id;\n    }\n    const messageMissing = !this.messages[id];\n    const missing = this._missing;\n    if (missing && messageMissing) {\n      return isFunction(missing) ? missing(this._locale, id) : missing;\n    }\n    if (messageMissing) {\n      this.emit(\"missing\", { id, locale: this._locale });\n    }\n    let translation = this.messages[id] || message || id;\n    if (process.env.NODE_ENV !== \"production\") {\n      translation = isString(translation) ? compileMessage(translation) : translation;\n    }\n    if (isString(translation) && UNICODE_REGEX.test(translation))\n      return JSON.parse(`\"${translation}\"`);\n    if (isString(translation))\n      return translation;\n    return interpolate(\n      translation,\n      this._locale,\n      this._locales\n    )(values, formats);\n  }\n  date(value, format) {\n    return date(this._locales || this._locale, value, format);\n  }\n  number(value, format) {\n    return number(this._locales || this._locale, value, format);\n  }\n}\nfunction setupI18n(params = {}) {\n  return new I18n(params);\n}\n\nconst i18n = setupI18n();\n\nexport { I18n, formats, i18n, setupI18n };\n","import { Messages, i18n } from '@lingui/core';\n\nexport const supportedLocales = ['en', 'nb', 'fi'] as const;\ntype SupportedLocale = (typeof supportedLocales)[number];\n\nexport const defaultLocale = 'en';\n\nexport const getSupportedLocale = (usedLocale: string) => {\n  return (\n    supportedLocales.find(\n      (locale) =>\n        usedLocale === locale || usedLocale.toLowerCase().includes(locale)\n    ) || defaultLocale\n  );\n};\n\nexport function detectLocale(): SupportedLocale {\n  if (typeof window === 'undefined') {\n    /**\n     * Server locale detection. This requires e.g LANG environment variable to be set on the server.\n     */\n    const serverLocale =\n      process.env.NMP_LANGUAGE ||\n      Intl.DateTimeFormat().resolvedOptions().locale;\n    return getSupportedLocale(serverLocale);\n  }\n\n  try {\n    /**\n     * Client locale detection. Expects the lang attribute to be defined.\n     */\n    const htmlLocale = document.documentElement.lang;\n    return getSupportedLocale(htmlLocale);\n  } catch (e) {\n    console.warn('could not detect locale, falling back to source locale', e);\n    return defaultLocale;\n  }\n}\n\nexport const getMessages = (\n  locale: SupportedLocale,\n  enMsg: Messages,\n  nbMsg: Messages,\n  fiMsg: Messages\n) => {\n  if (locale === 'nb') return nbMsg;\n  if (locale === 'fi') return fiMsg;\n  // Default to English\n  return enMsg;\n};\n\nexport const activateI18n = (\n  enMessages: Messages,\n  nbMessages: Messages,\n  fiMessages: Messages\n) => {\n  const locale = detectLocale();\n  const messages = getMessages(locale, enMessages, nbMessages, fiMessages);\n  i18n.load(locale, messages);\n  i18n.activate(locale);\n};\n"],"names":["exports","ErrorType","dist","errors_1","require$$0","parseHexToInt","hex","validateAndParseHex","errorName","enforcedLength","parsedHex","parseHexadecimalCode","code","parsedCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","parseUnicodeCodePointCode","codePoint","withoutBraces","err","parseOctalCode","error","singleCharacterEscapes","parseSingleCharacterCode","escapeMatch","unraw","raw","allowOctals","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","_default","isString","s","isFunction","f","cache","normalizeLocales","locales","date","value","format","_locales","getMemoized","cacheKey","number","plural","ordinal","offset","rules","plurals","getKey","construct","key","formatter","type","options","localeKey","UNICODE_REGEX","getDefaultFormats","locale","formats","style","replaceOctothorpe","message","numberFormat","valueStr","cases","interpolate","translation","values","formatters","formatMessage","message2","token","name","interpolatedFormat","result","EventEmitter","event","listener","index","args","I18n","params","localeData","localeOrAllData","messages","localeOrMessages","id","messageMissing","missing","setupI18n","i18n","define_process_env_default"],"mappings":"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","x_google_ignoreList":[0,1,2]}